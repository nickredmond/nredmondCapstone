package featureExtraction;

import java.awt.Point;
import java.util.ArrayList;
import java.util.List;

public class ChainCodeCreator {
	private static final int VISITED = -1;
	//private static final int NON_VISITED = 1;
	
	public static int[] generateChainCode(int[][] skeletonValues){		
		List<Integer> chainCodeValues = new ArrayList<Integer>();
		List<FeaturePoint> featurePoints = VectorCalculator.calculateFeaturePointLocations(skeletonValues);
		
		boolean foundStartingPt = false;
		for (int i = 0; i < featurePoints.size() && !foundStartingPt; i++){
			FeaturePoint nextPoint = featurePoints.get(i);
			if (nextPoint.getType() == FeatureType.END_POINT){
				foundStartingPt = true;
				skeletonValues[nextPoint.y()][nextPoint.x()] = VISITED;
				findNextPixel(skeletonValues, chainCodeValues, nextPoint.y(), nextPoint.x(), VectorDirection.TOP);
			}
		}
		
		for (int row = 0; row < skeletonValues.length; row++){
			for (int col = 0; col < skeletonValues[0].length; col++){
				if (skeletonValues[row][col] > 0){
					skeletonValues[row][col] = VISITED;
					findNextPixel(skeletonValues, chainCodeValues, row, col, VectorDirection.TOP);
				}
			}
		}
		
		int[] chainCode = new int[chainCodeValues.size()];
		
		System.out.print("CHAIN CODE: ");
		for (int i = 0; i < chainCodeValues.size(); i++){
			chainCode[i] = chainCodeValues.get(i);
			System.out.print(chainCode[i] + " ");
		}
		System.out.println("\r\n");
		
		return chainCode;
	}
	
	private static void findNextPixel(int[][] skeletonValues, List<Integer> chainCodeValues, int row, int col, VectorDirection previousDirection){
		VectorDirection[] directions = VectorDirection.values();
		
		int previousDirectionValue = previousDirection.ordinal();
		int directionLeft = previousDirectionValue - 1;
		int directionRight = previousDirectionValue + 1;
		boolean hasCompletedCircle = false;
		boolean hasTraversed = false;
		
		if (chainCodeValues.size() == 14){
			int x = 3;
		}
		
		while (!hasCompletedCircle && !hasTraversed){
			int correctedLeft = (directionLeft >= 0) ? directionLeft : directionLeft + directions.length;
			int correctedRight = (directionRight < directions.length) ? directionRight : directionRight - directions.length;
			
			Point nextLeftPoint = directions[correctedLeft].getNextPixelPoint(row, col, skeletonValues);
			Point nextRightPoint = directions[correctedRight].getNextPixelPoint(row, col, skeletonValues);
			int nextLeftValue = (nextLeftPoint.x != -1 && nextLeftPoint.y != -1) ? skeletonValues[nextLeftPoint.y][nextLeftPoint.x] : 0;
			int nextRightValue = (nextRightPoint.x != -1 && nextRightPoint.y != -1) ? skeletonValues[nextRightPoint.y][nextRightPoint.x] : 0;
			
			if (nextLeftValue > 0){
				traverseToNextPoint(skeletonValues, chainCodeValues, row, col,
						directions, directions[correctedLeft], nextLeftPoint);
				hasTraversed = true;
			}
			else if (nextRightValue > 0){
				traverseToNextPoint(skeletonValues, chainCodeValues, row, col,
						directions, directions[correctedRight], nextRightPoint);
				hasTraversed = true;
			}
			
			if (correctedLeft == correctedRight){
				hasCompletedCircle = true;
			}
			directionLeft--;
			directionRight++;
		}
		
//		for (int i = 0; i < directions.length && !hasTraversed; i++){
//			Point nextSurroundingPoint = directions[i].getNextPixelPoint(row, col, skeletonValues);
//			int nextPointValue = (nextSurroundingPoint.x != -1 && nextSurroundingPoint.y != -1) ? skeletonValues[nextSurroundingPoint.y][nextSurroundingPoint.x] : 0;
//			
//			if (nextPointValue > 0){
//				if (i == 4 && col > 6 && row == 18){
//					System.out.println("col: " + col + ", row: " + row);
//				}
//				
//				chainCodeValues.add(directions[i].ordinal());
//				skeletonValues[row][col] = VISITED;
//				
//				findNextPixel(skeletonValues, chainCodeValues, nextSurroundingPoint.y, nextSurroundingPoint.x);
//				hasTraversed = true;
//			}
//		}
	}

	private static void traverseToNextPoint(int[][] skeletonValues, List<Integer> chainCodeValues, int row, int col,
			VectorDirection[] directions, VectorDirection nextDirection, Point nextPoint) {
		chainCodeValues.add(directions[nextDirection.ordinal()].ordinal());
		skeletonValues[row][col] = VISITED;
		
		findNextPixel(skeletonValues, chainCodeValues, nextPoint.y, nextPoint.x, nextDirection);
	}	
}
