package imageProcessing;

import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

import debug.FeatureExtractionDebug;
import featureExtraction.CrossingCalculator;
import featureExtraction.ImageThinner;
import featureExtraction.MomentCalculator;
import featureExtraction.VectorCalculator;

public class FeatureExtractionIOTranslator implements INetworkIOTranslator {
	private final static int NUMBER_VERTICAL_BINS = 6;
	private final static int NUMBER_HORIZONTAL_BINS = 7;
	
	private static final int NUMBER_PROFILE_DIRECTIONS = 4;
	
	public final static int DEFAULT_INPUT_LENGTH = 7 + (NUMBER_PROFILE_DIRECTIONS * 3) + 16 + 2; // plus 24 w/ original values
	private int inputLength;
	
	private final int ZONING_DIMENSION_X = 4;
	private final int ZONING_DIMENSION_Y = 4;
	
	private final float TOP_DIMENSION_PERCENT = 0.3f;
	private final float MID_DIMENSION_PERCENT = 0.5f;
	private final float BOTTOM_DIMENSION_PERCENT = 0.8f;
	
	private final float GAMMA = 2.2f;
	private final float R_LUMINANCE = 0.2126f;
	private final float G_LUMINANCE = 0.7152f;
	private final float B_LUMINANCE = 0.0722f;
	
	private final int MAX_NUMBER_CROSSINGS = 4;
	
	private final int DARK_BOUNDARY = 5000;
	
	// testing method
//	public void printImageBinary(BufferedImage img){
//		int[][] lightValues = getLightValues(img);
//		int[][] croppedLightValues = cropLightValues(lightValues);
//		printImg(croppedLightValues);
//	}
	
	public FeatureExtractionIOTranslator(){
		BufferedImage img = new BufferedImage(4, 4, BufferedImage.TYPE_INT_RGB);
		
		for (int row = 0; row < img.getHeight(); row++)
		{
			for (int col = 0; col < img.getWidth(); col++){
				img.setRGB(col, row, -1);
			}
		}
		
		translateImageToNetworkInput(img);
	}
	
	@Override
	public char translateNetworkOutputToCharacter(float[] output) {
		return new NetworkIOTranslator().translateNetworkOutputToCharacter(output);
	}

	@Override
	public int[] translateCharacterToNetworkOutput(char c) {
		return new NetworkIOTranslator().translateCharacterToNetworkOutput(c);
	}

	@Override
	public float[] translateImageToNetworkInput(BufferedImage img) {
		
		int[][] lightValues = getLightValues(img);
		int[][] croppedLightValues = cropLightValues(lightValues);
		float[] input = new float[DEFAULT_INPUT_LENGTH];
		
		if(croppedLightValues.length > 1 && croppedLightValues[0].length > 1){					
			float[] percentages = {TOP_DIMENSION_PERCENT, MID_DIMENSION_PERCENT, BOTTOM_DIMENSION_PERCENT};
			
			if (croppedLightValues[0].length < ZONING_DIMENSION_X || croppedLightValues.length < ZONING_DIMENSION_Y){
				croppedLightValues = padWithSpace(croppedLightValues);
			}
			
			List<Float> inputList = new ArrayList<Float>();
			
			//addHuMomentFeatures(inputList, croppedLightValues);
			addProfilingFeatures(inputList, croppedLightValues, percentages);
			addVectorFeatures(inputList, croppedLightValues);
			addCrossingFeatures(inputList, croppedLightValues);
			
			inputList.add(getHeightToWidthRatio(croppedLightValues));
			
//			inputList.add(getVerticalSymmetryValue(croppedLightValues));
//			inputList.add(getHorizontalSymmetryValue(croppedLightValues));
//			
//			addPercentDimensionFeatures(inputList, croppedLightValues, percentages);
//			addZoningFeatures(inputList, croppedLightValues);
			
			input = new float[inputList.size()];
			
			for (int i = 0; i < input.length; i++){
				input[i] = inputList.get(i);
			}
			
			for (int i = 0; i < input.length; i++){
				if (input[i] != input[i]){
					FeatureExtractionDebug.printImg(croppedLightValues);
				}
			}
			
			inputLength = input.length;
		}
		
		return input;
	}
	
	private int[][] padWithSpace(int[][] croppedLightValues) {
		int width = (croppedLightValues[0].length < ZONING_DIMENSION_X) ? ZONING_DIMENSION_X : croppedLightValues[0].length;
		int height = (croppedLightValues.length < ZONING_DIMENSION_Y) ? ZONING_DIMENSION_Y : croppedLightValues.length;
		
		int[][] paddedLightValues = new int[height][width];
		
		for (int row = 0; row < croppedLightValues.length; row++){
			for (int col = 0; col < croppedLightValues[0].length; col++){
				paddedLightValues[row][col] = croppedLightValues[row][col];
			}
		}
		
		return paddedLightValues;
	}
	
	private void addZoningFeatures(List<Float> inputList, int[][] croppedLightValues){
		float[] zoningValues = getZoningValues(croppedLightValues);
		
		for (int i = 0; i < zoningValues.length; i++){
			inputList.add(zoningValues[i]);
		}
	}
	
	private void addPercentDimensionFeatures(List<Float> inputList, int[][] croppedLightValues, float[] percentages){
		for (int i = 0; i < percentages.length; i++){
			inputList.add(getHeightPercentage(percentages[i], croppedLightValues));
		}
		
		for (int i = 0; i < percentages.length; i++){
			inputList.add(getWidthPercentage(percentages[i], croppedLightValues));
		}
	}
	
	private void addProfilingFeatures(List<Float> inputList, int[][] croppedLightValues, float[] percentages){
		float[] profilingValues = new float[NUMBER_PROFILE_DIRECTIONS * percentages.length];
		
		for (int i = 0; i < percentages.length; i++){
			int index = NUMBER_PROFILE_DIRECTIONS * i;
			profilingValues[index] = getTopProfileAtPercent(percentages[i], croppedLightValues);
			profilingValues[index + 1] = getRightProfileAtPercent(percentages[i], croppedLightValues);
			profilingValues[index + 2] = getBottomProfileAtPercent(percentages[i], croppedLightValues);
			profilingValues[index + 3] = getLeftProfileAtPercent(percentages[i], croppedLightValues);
		}
		
		for (int i = 0; i < profilingValues.length; i++){
			inputList.add(profilingValues[i]);
		}
	}
	
	private void addHuMomentFeatures(List<Float> inputList, int[][] croppedLightValues){
		float[] huMoments = MomentCalculator.calculateHuInvariantMoments(croppedLightValues);
		
		for (int i = 0; i < huMoments.length; i++){
			inputList.add(huMoments[i]);
		}
	}
	
	private void addCrossingFeatures(List<Float> inputList, int[][] croppedLightValues){
		Point centroid = MomentCalculator.calculateCentroid(croppedLightValues);		
		int vertCrossings = CrossingCalculator.getNumberVerticalCrossings(centroid.x, croppedLightValues);
		int horizCrossings = CrossingCalculator.getNumberHorizontalCrossings(centroid.y, croppedLightValues);
		
		inputList.add((float)vertCrossings / MAX_NUMBER_CROSSINGS);
		inputList.add((float)horizCrossings / MAX_NUMBER_CROSSINGS);
	}

	private void addVectorFeatures(List<Float> inputList, int[][] croppedLightValues){
		ImageThinner thinner = new ImageThinner();
		thinner.thinImage(croppedLightValues);
		
		float[] zoneVectors = VectorCalculator.calculateZonedVectorsForSkeleton(croppedLightValues, ZONING_DIMENSION_Y, ZONING_DIMENSION_Y);
		
		for (int i = 0; i < zoneVectors.length; i++){
			inputList.add(zoneVectors[i]);
		}
	}
	
	private float getHeightToWidthRatio(int[][] lightValues){
		float htwRatio = 0.0f;
		boolean isSpaceCharacter = true;
		int height = lightValues.length;
		int width = lightValues[0].length;
		
		for (int row = 0; row < lightValues.length && isSpaceCharacter; row++){
			for (int col = 0; col < lightValues[0].length && isSpaceCharacter; col++){
				isSpaceCharacter = (lightValues[row][col] == 0);
			}
		}
		
		if (isSpaceCharacter || (height == width)){
			htwRatio = 1.0f;
		}
		else if (height > width){
			htwRatio = (float)width / height;
		}
		else htwRatio = (-1.0f * height) / width;
		
		return htwRatio;
	}
	
	private float getLeftProfileAtPercent(float percentHeight, int[][] lightValues){
		int row = (int)(percentHeight * lightValues.length);
		boolean foundCharacter = false;
		int currentColumn = 0;
		
		for (int col = 0; col < lightValues[row].length && !foundCharacter; col++){
			foundCharacter = (lightValues[row][col] == 1);
			currentColumn = col;
		}
		
		return (float)currentColumn / lightValues[row].length;
	}
	
	private float getRightProfileAtPercent(float percentHeight, int[][] lightValues){
		int row = (int)(percentHeight * lightValues.length);
		boolean foundCharacter = false;
		int currentColumn = lightValues[row].length - 1;
		
		for (int col = lightValues[row].length - 1; col >= 0 && !foundCharacter; col--){
			foundCharacter = (lightValues[row][col] == 1);
			currentColumn = col;
		}
		
		return (float)(lightValues[row].length - 1 - currentColumn) / lightValues[row].length;
	}
	
	private float getTopProfileAtPercent(float percentWidth, int[][] lightValues){
		int col = (int) (percentWidth * lightValues[0].length);
		boolean foundCharacter = false;
		int currentRow = 0;
		
		for (int row = 0; row < lightValues.length && !foundCharacter; row++){
			foundCharacter = (lightValues[row][col] == 1);
			currentRow = row;
		}
		
		return (float)currentRow / lightValues.length;
	}
	
	private float getBottomProfileAtPercent(float percentWidth, int[][] lightValues){
		int col = (int) (percentWidth * lightValues[0].length);
		boolean foundCharacter = false;
		int currentRow = lightValues.length - 1;
		
		for (int row = lightValues.length - 1; row >= 0 && !foundCharacter; row--){
			foundCharacter = (lightValues[row][col] == 1);
			currentRow = row;
		}
		
		return (float)(lightValues.length - 1 - currentRow) / lightValues.length;
	}
	
	private int[][] cropLightValues(int[][] lightValues){
		Rectangle croppedRectangle = getCroppedLightValueRectangle(lightValues);
		
		int[][] croppedLightValues = new int[croppedRectangle.height][croppedRectangle.width];
		
		int croppedRow = 0;
		int croppedCol = 0;
		
		for (int row = croppedRectangle.x; row < croppedRectangle.x + croppedRectangle.height &&
				row < lightValues.length; row++){
			for (int col = croppedRectangle.y; col < croppedRectangle.y + croppedRectangle.width &&
					col < lightValues[0].length; col++){
				croppedLightValues[croppedRow][croppedCol] = lightValues[row][col];
				croppedCol++;
			}
			
			croppedCol = 0;
			croppedRow++;
		}
		
		return croppedLightValues;
	}
	
	private Rectangle getCroppedLightValueRectangle(int[][] lightValues){
		int startingRow = -1;
		int endingRow = -1;
		int startingCol = -1;
		int endingCol = -1;
		
		for (int row = 0; row < lightValues.length; row++){
			for (int col = 0; col < lightValues[0].length; col++){
				boolean isDark = (lightValues[row][col] == 1);
				
				if (isDark){
					startingRow = (startingRow < 0) ? row : startingRow;
					endingRow = (endingRow < 0) ? endingRow : -1;
					
					startingCol = (startingCol > col || startingCol < 0) ? col : startingCol;
					endingCol = (endingCol < col) ? -1 : endingCol;
				}
				else{
					endingRow = (endingRow < 0) ? row : endingRow;
					endingCol = (endingCol < 0 && startingCol >= 0) ? col : endingCol;
				}
			}
			if (endingCol < 0){
				endingCol = lightValues[0].length - 1;
			}
		}
		
		startingRow = (startingRow == -1) ? 0 : startingRow;
		endingRow = (endingRow <= 0) ? lightValues.length : endingRow;
		startingCol = (startingCol == -1) ? 0 : startingCol;
		endingCol = (endingCol <= 0) ? lightValues[0].length : endingCol;
		
		return new Rectangle(startingRow, startingCol, endingCol - startingCol, endingRow - startingRow);
	}

	public int[][] getLightValues(BufferedImage img){
		int[][] lightValues = new int[img.getHeight()][img.getWidth()];
		
		for (int x = 0; x < img.getWidth(); x++){
			for (int y = 0; y < img.getHeight(); y++){
				int rgbValue = img.getRGB(x, y);
				int rVal = (rgbValue >> 16) & 0xff;
				int gVal = (rgbValue >> 8) & 0xff;
				int bVal = (rgbValue) & 0xff;
				
				float rLinear = (float) Math.pow(rVal, GAMMA);
				float gLinear = (float) Math.pow(gVal, GAMMA);
				float bLinear = (float) Math.pow(bVal, GAMMA);
				
				float luminance = (R_LUMINANCE * rLinear) + (G_LUMINANCE + gLinear) +
						(B_LUMINANCE * bLinear);
				
				int lightness = (int) (116 * Math.pow(luminance, 0.3333) - 16);
				lightValues[y][x] = (lightness < DARK_BOUNDARY) ? 0 : 1;
			}
		}
		
		invertLightValues(lightValues);
		return lightValues;
	}
	
	private void invertLightValues(int[][] lightValues) {
		for (int row = 0; row < lightValues.length; row++){
			for (int col = 0; col < lightValues[row].length; col++){
				lightValues[row][col] = ((lightValues[row][col] == 0) ? 1 : 0);
			}
		}
	}
	
	private float getSumOfFeatures(List<Float> input){
		float sum = 0.0f;
		
		for (int i = 0; i < input.size(); i++){
			sum += input.get(i);
		}
		
		return sum;
	}

	private float getWidthPercentage(float percentTotalHeight, int[][] lightValues){
		int row = (int)(percentTotalHeight * lightValues.length);
		int widthSum = 0;
		
		for (int col = 0; col < lightValues[row].length; col++){
			widthSum += lightValues[row][col];
		}
		
		return (float)widthSum / lightValues[0].length;
	}
	
	private float getHeightPercentage(float percentTotalWidth, int[][] lightValues){
		int col = (int)(percentTotalWidth * lightValues[0].length);
		int heightSum = 0;
		for (int row = 0; row < lightValues.length; row++){
			heightSum += lightValues[row][col];
		}
		
		return (float)heightSum / lightValues.length;
	}
	
	private float getHorizontalSymmetryValue(int[][] lightValues){
		int imageHalf = lightValues.length / 2;
		float totalSymmetryDifference = 0;
		
		for (int col = 0; col < lightValues[0].length; col++){
			int colSymmetryDifference = 0;
			
			for (int distance = 0; distance < imageHalf; distance++){				
				int topRow = imageHalf - 1 - distance;
				int bottomRow = imageHalf + distance;
				
				int topLightValue = lightValues[topRow][col];
				int bottomLightValue = lightValues[bottomRow][col];
				
				colSymmetryDifference += Math.abs(topLightValue - bottomLightValue);
			}
		//	colSymmetryDifference *= (1.001f * (colSymmetryDifference + 1));
			totalSymmetryDifference += (float)colSymmetryDifference / imageHalf;
		}
		
		return (float)totalSymmetryDifference / lightValues[0].length;
	}
	
	private float getVerticalSymmetryValue(int[][] lightValues){ // DO THIS
		int imageHalf = lightValues[0].length / 2;
		float totalSymmetryDifference = 0;
		
		for (int row = 0; row < lightValues.length; row++){
			int rowSymmetryDifference = 0;
			
			for (int distance = 0; distance < imageHalf; distance++){				
				int leftCol = imageHalf - 1 - distance;
				int rightCol = imageHalf + distance;
				
				int leftLightValue = lightValues[row][leftCol];
				int rightLightValue = lightValues[row][rightCol];
				
				rowSymmetryDifference += Math.abs(leftLightValue - rightLightValue);
			}
		//	rowSymmetryDifference *= (1.001f * (rowSymmetryDifference + 1));
			totalSymmetryDifference += (float)rowSymmetryDifference / imageHalf;
		}
		
		return (float)totalSymmetryDifference / lightValues.length;
	}
	
	private float[] getZoningValues(int[][] lightValues){
		float[] zoningValues = new float[ZONING_DIMENSION_X * ZONING_DIMENSION_Y];
		
		int numRowsPerZone = lightValues.length / ZONING_DIMENSION_X;
		int numColsPerZone = lightValues[0].length / ZONING_DIMENSION_Y;
		
		for (int x = 0; x < ZONING_DIMENSION_X; x++){
			for (int y = 0; y < ZONING_DIMENSION_Y; y++){
				
				int nextZoningIndex = (x * ZONING_DIMENSION_X) + y;
				float nextZoneValue = getNextZoningValue(x, y, numRowsPerZone, numColsPerZone, lightValues);
				zoningValues[nextZoningIndex] = nextZoneValue;
			}
		}
		
		return zoningValues;
	}

	private float getNextZoningValue(int row, int col, int numRowsPerZone,
			int numColsPerZone, int[][] lightValues) {
		int startingRow = row * numRowsPerZone;
		int endingRow = (row + 1) * numRowsPerZone;
		int startingCol = col * numColsPerZone;
		int endingCol = (col + 1) * numColsPerZone;
		
		int lightValueSum = 0;
		int numValues = 0;
		
		for (int currentRow = startingRow; currentRow < endingRow; currentRow++){
			for (int currentCol = startingCol; currentCol < endingCol; currentCol++){
				lightValueSum += lightValues[currentRow][currentCol];
				numValues++;
			}
		}
		
		return (float)lightValueSum / numValues;
	}
	
	private void doStuff(int[][] croppedLightValues, float[] input){
		
	}

	public int getInputLength() {
		return inputLength;
	}

	public void setInputLength(int inputLength) {
		this.inputLength = inputLength;
	}
}
