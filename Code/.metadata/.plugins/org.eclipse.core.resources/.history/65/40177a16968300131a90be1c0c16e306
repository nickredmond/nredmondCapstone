package featureExtraction;

import java.awt.Point;

public class ImageNormalizer {
	public static int[][] normalizeImageOnCentroidScaleInvariant(int[][] imageValues, int beta){
		int[][] centeredImgValues = centerAroundCentroid(imageValues);
		return centeredImgValues;
	}
	
	private static int[][] copyImage(int[][] imageValues){
		int[][] copy = new int[imageValues.length][imageValues[0].length];
		
		for (int row = 0; row < imageValues.length; row++){
			for (int col = 0; col < imageValues[0].length; col++){
				copy[row][col] = imageValues[row][col];
			}
		}
		
		return copy;
	}
	
	private static int[][] centerAroundCentroid(int[][] imageValues){
		int[][] modifiedValues = new int[imageValues.length][imageValues[0].length];
		Point centroid = MomentCalculator.calculateCentroid(imageValues);
		
		int leftOfCentroid = centroid.x;
		int rightOfCentroid = imageValues[0].length - leftOfCentroid;
		int aboveCentroid = centroid.y;
		int belowCentroid = imageValues.length - aboveCentroid;
		
		if (belowCentroid > rightOfCentroid){
			modifiedValues = padRight(imageValues, (belowCentroid - rightOfCentroid));
		}
		else if (belowCentroid < rightOfCentroid){
			modifiedValues = padDown(imageValues, (rightOfCentroid - belowCentroid));
		}
		else modifiedValues = copyImage(imageValues);
		
		if (leftOfCentroid < rightOfCentroid){
			padLeft(modifiedValues, (rightOfCentroid - leftOfCentroid));
		}
		else if (leftOfCentroid > rightOfCentroid){
			padRight(modifiedValues, (leftOfCentroid - rightOfCentroid));
		}
		
		if (aboveCentroid < belowCentroid){
			padUp(modifiedValues, (belowCentroid - aboveCentroid));
		}
		else if (aboveCentroid > belowCentroid){
			padDown(modifiedValues, (aboveCentroid - belowCentroid));
		}
		
		return modifiedValues;
	}

	private static int[][] padRight(int[][] imageValues, int length) {
		int[][] paddedValues = new int[imageValues.length][imageValues[0].length + length];
		
		for (int row = 0; row < imageValues.length; row++){
			for (int col = 0; col < paddedValues[0].length; col++){
				paddedValues[row][col] = (col < imageValues[0].length) ? imageValues[row][col] : 0;
			}
		}
		
		return paddedValues;
	}
	
	private static int[][] padLeft(int[][] imageValues, int length) {
		int[][] paddedValues = new int[imageValues.length][imageValues[0].length + length];
		
		for (int row = 0; row < imageValues.length; row++){
			for (int col = 0; col < paddedValues[0].length; col++){
				paddedValues[row][col] = (col >= length) ? imageValues[row][col] : 0;
			}
		}
		
		return paddedValues;
	}
	
	private static int[][] padDown(int[][] imageValues, int length) {
		int[][] paddedValues = new int[imageValues.length + length][imageValues[0].length];
		
		for (int row = 0; row < paddedValues.length; row++){
			for (int col = 0; col < imageValues[0].length; col++){
				paddedValues[row][col] = (row < imageValues.length) ? imageValues[row][col] : 0;
			}
		}
		
		return paddedValues;
	}
	
	private static int[][] padUp(int[][] imageValues, int length) {
		int[][] paddedValues = new int[imageValues.length + length][imageValues[0].length];
		
		for (int row = 0; row < paddedValues.length; row++){
			for (int col = 0; col < imageValues[0].length; col++){
				paddedValues[row][col] = (row >= length) ? imageValues[row][col] : 0;
			}
		}
		
		return paddedValues;
	}
}
