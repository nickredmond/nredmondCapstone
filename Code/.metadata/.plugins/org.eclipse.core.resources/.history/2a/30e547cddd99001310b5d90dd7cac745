package decisionTrees;

import genetics.BasicGeneticAlgorithm;
import genetics.IChromosomeChooser;
import genetics.IFitnessCalculator;
import genetics.MetaclassFitnessCalculator;
import genetics.TournamentChooser;

import java.util.Set;

import neuralNetwork.CharacterTrainingExample;

public class OptimalTreeFinder {
	private Set<CharacterTrainingExample> trainingSet, testSet;
	private float minRequiredFitness;
	private char[] classes;
	private int numberLeafClasses;
	private IChromosomeChooser chooser;

	private final float DEFAULT_REQUIRED_FITNESS = 0.1f;
	private final int DEFAULT_NUMBER_LEAF_CLASSES = 3;
	
	public OptimalTreeFinder(Set<CharacterTrainingExample> trainingSet, Set<CharacterTrainingExample> testSet, char[] classes){
		this.trainingSet = trainingSet;
		this.testSet = testSet;
		this.classes = classes;
		
		chooser = new TournamentChooser();
		
		minRequiredFitness = DEFAULT_REQUIRED_FITNESS;
	}
	
	public MetaclassTree getOptimalTree(){
		
		
		return null;
	}
	
	private void addNodesToTree(MetaclassNode parent){
		IFitnessCalculator fitnessCalc = new MetaclassFitnessCalculator(trainingSet, testSet, classes);
		BasicGeneticAlgorithm geneticAlgo = new BasicGeneticAlgorithm(fitnessCalc, chooser);
		
		int[][] chromosomes = geneticAlgo.generateRandomChromosomeSet(numberChromosomes, chromosomeLength)
	}
	
	public void setNumberLeafClasses(int numberClasses){
		numberLeafClasses = numberClasses;
	}

	public float getMinRequiredFitness() {
		return minRequiredFitness;
	}

	public void setMinRequiredFitness(float minRequiredFitness) {
		this.minRequiredFitness = minRequiredFitness;
	}
}
