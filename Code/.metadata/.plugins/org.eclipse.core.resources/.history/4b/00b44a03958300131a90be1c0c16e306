package featureExtraction;

import java.awt.Point;

public class ImageNormalizer {
	public int[][] normalizeImageOnCentroidScaleInvariant(int[][] imageValues, int beta){
		Point centroid = MomentCalculator.calculateCentroid(imageValues);
		int[][] modifiedValues = new int[imageValues.length][imageValues[0].length];
		
		int leftOfCentroid = centroid.x;
		int rightOfCentroid = imageValues[0].length - leftOfCentroid;
		int aboveCentroid = centroid.y;
		int belowCentroid = imageValues.length - aboveCentroid;
		
		if (belowCentroid > rightOfCentroid){
			modifiedValues = padRight(imageValues, (belowCentroid - rightOfCentroid));
		}
		else if (belowCentroid < rightOfCentroid){
			modifiedValues = padDown(imageValues, (rightOfCentroid - belowCentroid));
		}
		else modifiedValues = copyImage(imageValues);
		
		int halfHeight = imageValues.length / 2;
		int halfWidth = imageValues[0].length / 2;
		
		if (centroid.x < halfWidth){
			padLeft(modifiedValues)
		}
	}
	
	private int[][] copyImage(int[][] imageValues){
		int[][] copy = new int[imageValues.length][imageValues[0].length];
		
		for (int row = 0; row < imageValues.length; row++){
			for (int col = 0; col < imageValues[0].length; col++){
				copy[row][col] = imageValues[row][col];
			}
		}
		
		return copy;
	}

	private int[][] padRight(int[][] imageValues, int length) {
		int[][] paddedValues = new int[imageValues.length][imageValues[0].length + length];
		
		for (int row = 0; row < imageValues.length; row++){
			for (int col = 0; col < paddedValues[0].length; col++){
				paddedValues[row][col] = (col < imageValues[0].length) ? imageValues[row][col] : 0;
			}
		}
		
		return paddedValues;
	}
	
	private int[][] padLeft(int[][] imageValues, int length) {
		int[][] paddedValues = new int[imageValues.length][imageValues[0].length + length];
		
		for (int row = 0; row < imageValues.length; row++){
			for (int col = 0; col < paddedValues[0].length; col++){
				paddedValues[row][col] = (col >= length) ? imageValues[row][col] : 0;
			}
		}
		
		return paddedValues;
	}
	
	private int[][] padDown(int[][] imageValues, int length) {
		int[][] paddedValues = new int[imageValues.length + length][imageValues[0].length];
		
		for (int row = 0; row < paddedValues.length; row++){
			for (int col = 0; col < imageValues[0].length; col++){
				paddedValues[row][col] = (row < imageValues.length) ? imageValues[row][col] : 0;
			}
		}
		
		return paddedValues;
	}
	
	private int[][] padUp(int[][] imageValues, int length) {
		int[][] paddedValues = new int[imageValues.length + length][imageValues[0].length];
		
		for (int row = 0; row < paddedValues.length; row++){
			for (int col = 0; col < imageValues[0].length; col++){
				paddedValues[row][col] = (row >= length) ? imageValues[row][col] : 0;
			}
		}
		
		return paddedValues;
	}
}
