package featureExtraction;

import java.util.HashMap;
import java.util.Map;

public class VectorCalculator {
	private static final int EMPTY = 0;
	private static final int NON_VISITED = 1;
	private static final int HORIZONTAL = 3;
	private static final int VERTICAL = 2;
	private static final int DIAG_LEFT = 5;
	private static final int DIAG_RIGHT = 4;
	
	public static final int MAX_DIRECTION_VALUE = DIAG_LEFT;
	
	public static float[] calculateZonedVectorsForSkeleton(int[][] skeleton, int zoneDimensionX, int zoneDimensionY){
		int[][] vectorSkeleton = calculateVectorsForSkeleton(skeleton);
		float[] zonedValues = new float[zoneDimensionX * zoneDimensionY];
		int zoneValueIndex = 0;
		
		float numPixelsPerZoneX = (float)skeleton[0].length / zoneDimensionX;
		float numPixelsPerZoneY = (float)skeleton.length / zoneDimensionY;
		
		for (int zoneY = 0; zoneY < zoneDimensionY; zoneY++){
			for (int zoneX = 0; zoneX < zoneDimensionX; zoneX++){
				int startingRow = (int) (zoneY * numPixelsPerZoneY);
				int endingRow = (int) (startingRow + numPixelsPerZoneY);
				int startingCol = (int) (zoneX * numPixelsPerZoneX);
				int endingCol = (int) (startingCol + numPixelsPerZoneX);
				
				zonedValues[zoneValueIndex] = 
						calculateSumVectorValueForZone(startingRow, endingRow, startingCol, endingCol, vectorSkeleton);
				zoneValueIndex++;
			}
		}
		
		return zonedValues;
	}
	
	private static float calculateSumVectorValueForZone(int startingRow, int endingRow, int startingCol,
			int endingCol, int[][] vectorValues){
		Map<Integer, Integer> vectorCounts = new HashMap<Integer, Integer>();
		
		for (int row = startingRow; row <= endingRow; row++){
			for (int col = startingCol; col <= endingCol; col++){
				if (row < vectorValues.length && col < vectorValues[row].length && vectorValues[row][col] != 0){
					int vectorValue = (vectorCounts.get(vectorValues[row][col]) != null) ? vectorCounts.get(vectorValues[row][col]) : 0;
					vectorCounts.put(vectorValues[row][col], (vectorValue + 1));
				}
			}
		}
		
		int chosenVector = 0;
		int highestVectorCount = 0;
		
		for (Integer nextVectorDirection : vectorCounts.keySet()){
			int nextVectorCount = vectorCounts.get(nextVectorDirection);
			System.out.println("direction: " + nextVectorDirection + ", count: " + nextVectorCount);
			
			if (nextVectorCount > highestVectorCount){
				highestVectorCount = nextVectorCount;
				chosenVector = nextVectorDirection;
			}
		}
		
		return chosenVector / DIAG_LEFT;
	}
	
	private static float calculateVectorValueForZone(int startingRow,
			int endingRow, int startingCol, int endingCol, int[][] vectorValues) {
		int vectorSum = 0;
		int numVectorsFound = 0;
		
		for (int row = startingRow; row <= endingRow; row++){
			for (int col = startingCol; col <= endingCol; col++){
				if (row < vectorValues.length && col < vectorValues[row].length && vectorValues[row][col] != 0){
					vectorSum += vectorValues[row][col];
					numVectorsFound++;
				}
			}
		}
		
		return ((numVectorsFound > 0) ? ((float)vectorSum / numVectorsFound) : 0);
	}

	public static int[][] calculateVectorsForSkeleton(int[][] skeleton){
		int[][] skeletonCopy = copySkeleton(skeleton);
		
		for (int row = skeletonCopy.length - 1; row >= 0; row--){
			for (int col = 0; col < skeletonCopy[row].length; col++){
				if (skeletonCopy[row][col] == NON_VISITED){
					followSkeleton(row, col, skeletonCopy);
					
					if (skeletonCopy[row][col] == NON_VISITED){
						skeletonCopy[row][col] = VERTICAL;
					}
				}
			}
		}
		
		return skeletonCopy;
	}
	
	private static int[][] copySkeleton(int[][] skeleton){
		int[][] copy = new int[skeleton.length][skeleton[0].length];
		
		for (int row = 0; row < skeleton.length; row++){
			for (int col = 0; col < skeleton[0].length; col++){
				copy[row][col] = skeleton[row][col];
			}
		}
		
		return copy;
	}
	
	private static void followSkeleton(int row, int col, int[][] skeleton){ // recursive
		int left = (col - 1 >= 0) ? skeleton[row][col-1] : 0;
		int topLeft = (row - 1 >= 0 && col - 1 >= 0) ? skeleton[row-1][col-1] : 0;
		int top = (row - 1 >= 0) ? skeleton[row-1][col] : 0;
		int topRight = (row - 1 >= 0 && col + 1 < skeleton[row].length) ? skeleton[row-1][col+1] : 0;
		int right = (col + 1 < skeleton[row].length) ? skeleton[row][col+1] : 0;
		
		followIfNonVisited(row, col, topLeft, DIAG_LEFT, row-1, col-1, skeleton);
		followIfNonVisited(row, col, topRight, DIAG_RIGHT, row-1, col+1, skeleton);
		followIfNonVisited(row, col, left, HORIZONTAL, row, col-1, skeleton);
		followIfNonVisited(row, col, top, VERTICAL, row-1, col, skeleton);
		followIfNonVisited(row, col, right, HORIZONTAL, row, col+1, skeleton);
	}
	
	private static void followIfNonVisited(int currentRow, int currentCol, int searchValue, int markValue,
			int rowToAdvance, int colToAdvance, int[][] skeleton){
		if (searchValue == NON_VISITED){
			if (skeleton[currentRow][currentCol] == NON_VISITED){
				skeleton[currentRow][currentCol] = markValue;
			}
			followSkeleton(rowToAdvance, colToAdvance, skeleton);
		}
		else if (searchValue != EMPTY && skeleton[currentRow][currentCol] == NON_VISITED){
			skeleton[currentRow][currentCol] = markValue;
		}
	}
}
